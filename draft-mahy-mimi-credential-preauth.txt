



More Instant Messaging Interoperability                          R. Mahy
Internet-Draft                                           19 January 2026
Intended status: Informational                                          
Expires: 23 July 2026


   MIMI Preauthorization based on deep references to MLS Credentials
               draft-mahy-mimi-credential-preauth-latest

Abstract

   This document describes a syntax called claim pointers that
   facilitates comparisons in structured credentials, which often have
   nested levels of hierarchy.  It also describes an new version of the
   More Instant Messaging Interoperability (MIMI) preauthorization
   format using claim pointers.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://rohanmahy.github.io/mimi-credential-preauth/draft-mahy-mimi-
   credential-preauth.html.  Status information for this document may be
   found at https://datatracker.ietf.org/doc/draft-mahy-mimi-credential-
   preauth/.

   Discussion of this document takes place on the More Instant Messaging
   Interoperability Working Group mailing list (mailto:mimi@ietf.org),
   which is archived at https://mailarchive.ietf.org/arch/browse/mimi/.
   Subscribe at https://www.ietf.org/mailman/listinfo/mimi/.

   Source for this draft and an issue tracker can be found at
   https://github.com/rohanmahy/mimi-credential-preauth.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 23 July 2026.

Copyright Notice

   Copyright (c) 2026 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Structure of Credentials
   4.  Requirements for Credential Inspection
   5.  Matching claims
     5.1.  Matching Map Keys, Object Names, and
     5.2.  Matching Lists and Sequences by Absolute Position
     5.3.  Matching an Element in a List by an Identifier in the List
     5.4.  Matching multiple claim pointers
     5.5.  Matching with Numerical Predicates
     5.6.  Matching Parts of URIs and email addresses
     5.7.  Matching Arbitrary Substrings
   6.  some scraps here
   7.  Match Syntax Definition
   8.  More examples
     8.1.  CBOR Examples
       8.1.1.  CBOR example with tagged value access directly as
               opaque_value
       8.1.2.  CBOR example parsing into tagged value
       8.1.3.  CBOR example with custom simple values ?? - maybe not
               needed
     8.2.  X.509 Examples
       8.2.1.  Simple X.509 example (CN)
       8.2.2.  X.509 Matching one DNS item in issuerAltName
       8.2.3.  X.509 matching one URI part of subjectAltName
       8.2.4.  X.509 matching one URI part of subjectAltName with a
               domain substring
   9.  Old text on Preauth
   10. Security Considerations
   11. IANA Considerations
   12. Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   More Instant Messaging Interoperability (MIMI) room policy
   ([I-D.ietf-mimi-room-policy]) defines a format that allows potential
   joiners that are not enumerated beforehand to be preauthorized based
   on properties found in their Messaging Layer Security (MLS) [RFC9420]
   credentials.  The current version of the preauthorization format in
   Section 4 of [I-D.ietf-mimi-room-policy] is underspecified and was
   designed to work with individual claims in a JSON Web Token (JWT)
   [RFC7519] or CBOR Web Token (CWT) [RFC8392].  This document describes
   a syntax called claim pointers that can address claims nested inside
   JWT, CWT, and X.509 certificates [RFC5280], and provides richer
   matching rules for parts of those claims and predicates based on
   them.  It could also be extended to credentials based on most general
   purpose structured data formats.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Structure of Credentials

   Structured data formats use a handful of strategies for representing
   and organizing data.  All common structured data formats offer some
   type of record structure semantics.  In this context this means a
   record contains a group of fields.  The names for record and fields
   differ across formats, as do their specific representations, as shown
   in the table below.

   +==========+==========================+================+============+
   | Format   | Representation           | Identifier of  | Name of    |
   |          | of record                | field          | field      |
   +==========+==========================+================+============+
   | JSON     | object                   | name (quoted   | value      |
   |          | (preferred)              | string)        |            |
   +----------+--------------------------+----------------+------------+
   | JSON     | array                    | position       | value      |
   +----------+--------------------------+----------------+------------+
   | CBOR     | map (slight              | map key (often | value      |
   |          | preference)              | an integer)    |            |
   +----------+--------------------------+----------------+------------+
   | CBOR     | array                    | position       | element    |
   +----------+--------------------------+----------------+------------+
   | ASN.1    | sequence                 | position or    | element    |
   |          |                          | OID            |            |
   +----------+--------------------------+----------------+------------+
   | TLS PL   | struct                   | field name     | value      |
   +----------+--------------------------+----------------+------------+
   | TLS PL   | vector (not used         | position       | value      |
   |          | for records)             |                |            |
   +----------+--------------------------+----------------+------------+
   | ProtoBuf | struct or                | integer field  | ??         |
   |          | record?                  | identifier     |            |
   +----------+--------------------------+----------------+------------+
   | msgpack  |                          |                |            |
   +----------+--------------------------+----------------+------------+
   | XML      | element                  | XMLPath or id  | contents   |
   |          |                          | attribute      | of element |
   +----------+--------------------------+----------------+------------+
   | XML      | attribute                | XMLPath        | value of   |
   |          |                          |                | attribute  |
   +----------+--------------------------+----------------+------------+
   | CSV      | line                     | position       | field      |
   +----------+--------------------------+----------------+------------+
   | TOML     | group                    | name           | entry?     |
   +----------+--------------------------+----------------+------------+
   | SQL      | row                      | column name    | column/    |
   |          |                          |                | field      |
   +----------+--------------------------+----------------+------------+
   | YANG     |                          |                |            |
   +----------+--------------------------+----------------+------------+

                                  Table 1

   In this document, we are primarily interested in structured formats
   commonly used in credentials, specifically JSON Web Tokens (JWT),
   CBOR Web Tokens (CWT), and X.509 certificates (which use ASN.1) and
   their derivatives.  In the context of credentials each of these
   specific fields is often described as a claim.

   In JSON, a record is represented as an object by convention.  The
   individual fields in the record are identified by the object name,
   which is always a quoted string.  Very rarely a record is represented
   as an array of heterogeneous elements.  Credential claims in a JWT
   are present in the JWT payload object.  Lists of homogenous elements
   are also arrays.

   In CBOR a record is typically represented as a map (very often with
   assigned integer map keys).  Records could also be represented as an
   array of heterogeneous elements.  Lists of homogenous elements are
   also arrays.

   In X.509v3, a certificate contains an ASN.1 SEQUENCE of exactly 3
   elements, the tbsCertificate ("to be signed certificate", which is
   analogous to the certificate payload), the signature algorithm, and
   the signature.  The certificate "payload" record is an ASN.1 SEQUENCE
   of 6 mandatory elements (certificate serial number, signature
   algorithm, issuer, validity, subject, and subject public key) and up
   to four optional elements (version, issuer unique ID, subject unique
   ID, and extensions).  For the purpose of matching elements in the
   sequence we will assign an index to each field (starting from 0) as
   if all 10 elements were present.  In this way, the overall structure
   is addressed by absolute position, while specific names, types, and
   extensions are identified using registered Object Identifiers (OIDs).
   The extensions field contains a further syntax with a potentially
   large and varied basket of data structures.  Lists of items are
   represented as an ASN.1 SEQUENCE OF type, which if always of a single
   basic or composite type.  A composite type can contain a CHOICE of
   multiple subtypes.

   Records and lists in JSON, CBOR, and ASN.1 can be nested, sometimes
   deeply.  For example, the X.509 subjectAltName field can contain a
   list of different types of names (DNS, URI, email, etc.) that all
   represent the subject.  In JWT or CWT credentials, an address claim
   might consist of several component claims (ex: country or postal
   code); a language claim might consist of a list of languages; or a
   groups claim might contain nested claims only relevant to that
   specific group.

   It is common to have a list of specific permission that have been
   granted in one context but not another.  For example a public
   relations manager might have regular access to resource A by virtue
   of being part of a company, access to resource B by virtue of being a
   full-time employee, regular access to resource C by virtue of being
   located in a particular country or office, moderator access to
   resource D by virtue of being a in public relations, and
   administrator access to resource E by virtue of being a manager.

4.  Requirements for Credential Inspection

   The following requirements were considered necessary to have a
   successful credential matching mechanism.

   1.   The mechanism can represent the difference between no match, and
        a match with a null or undefined value.

   2.   The mechanism can find values in JSON objects and CBOR maps by
        the object name or key name.

   3.   The mechanism can find elements in ASN.1 by OID in a 2-element
        SEQUENCE.

   4.   The mechanism can find elements in lists or arrays by their
        position.

   5.   The mechanism can find elements in an ASN.1 SEQUENCE that has
        any combination of its optional elements.

   6.   The mechanism can find a single element in an list or array
        where one of the list/array elements contains a single
        "identifying" field somewhere in the array value.

   7.   The mechanism can find elements in array elements that require
        identification by multiple matching claim pointers (*Maybe*).

   8.   The mechanism can find numerical values matching simple numeric
        predicates, such as greater than, or less than or equal to.

   9.   The mechanism can find values matching well-defined parts of
        URIs and email addresses.

   10.  The mechanism can find values matching arbitrary substrings
        (*Maybe*).

   The following requirements were considered and rejected as out of
   scope.

   *  Can the mechanism find claim values matching regular expressions?
      No, since regular expressions often present a security footgun; as
      we are defining a mechanism expressly to be used with credentials,
      this is an unacceptable risk.

   *  Can the mechanism find claims using arbitrary combinations of
      boolean logical statements containing OR statements in a claim
      pointer?  No, as this is likely to allow an unbounded explosion of
      claim combinations, and an OR mechanism can be introduced at the
      level of the application using the claim pointer mechanism.

   *  Can the mechanism find claims with information from partial or
      incomplete nested map keys?  No, since JSON only supports strings
      as object names, and CWT does not map keys with maps or arrays.
      However, this might be a straightforward extension.

   *  Can the mechanism find multiple claims with a given query?  No,
      this would imply a mechanism that could return a set of
      arbitrarily disjoint trees, instead of returning a single result
      (or no match).

5.  Matching claims

   In this section we introduce a method of matching claims in
   credentials that we describe here as Claim Pointers.  A claim pointer
   follows the hierarchy of a credential from its root to a specific
   claim, through a sequence of specifiers per level.  Each level is
   described using a ClaimPointerUnit object.

   For the purposes of this section, a level of hierarchy in JSON is the
   value of any object, or an element of an array.  In CBOR a level of
   hierarchy is the value of any map key, an element of an array, or the
   contents of a tag.  In ASN.1 a level of hierarchy is an element of
   either a SEQUENCE or SEQUENCE OF.

   For explanatory purposes, we will provide an example JWT payload here
   to demonstrate some of the claim matching options.  Additional
   examples will be introduced as needed.

   {                                   # contents are at level 1
     "iss": "https://issuer.example",
     ...
     "known_entity": true,
     "orig_timestamp": 1549560720,
     "nodes": [                        # contents are at level 2
       {                               # contents are at level 3
         ...
         "processor": "DCBA-101777",
         "origin": {                   # contents are at level 4
           "country": "us",
           ...
         },
         "domain": "smart.example"
         "eur_per_hour": 273.15
       },
       ...
     ],
     "service_flags": [false, false, true, false]
   }

5.1.  Matching Map Keys, Object Names, and

   The value of an object in JSON or the value of a map in CBOR is
   accessed by its JSON name or CBOR map key, using the map_key pointer
   unit type.  For JSON the opaque_key to be compared with the key is a
   double-quoted JSON string that matches the object name.

   For CBOR the opaque_key is the ordinary encoding
   [I-D.ietf-cbor-serialization] that matches the map key.  For example
   the CBOR map keys of 1 (unsigned integer), -1 (negative integer), '1'
   (byte string), "1" (text string), 1(0) (a timestamp at the start of
   the UNIX epoch), and 1.0 (float) match the opaque_keys of 0x01, 0x20,
   0x41 0x31, 0x61 0x31, 0xC1 0x00, and 0xF9 0x3C 0x00 respectively.

   In X.509, a common pattern is to have a SEQUENCE of 2 elements
   consisting of an OID and data element (its "value").  The data
   element of such a 2 element SEQUENCE matches when its opaque_key is
   equal to the DER representation of its OID (excluding the OID type
   and length).

   This pointer unit points to ("returns") the value corresponding to
   the object name, map key, or element in the SEQUENCE.

   When evaluating the JWT payload above, the following claim pointer
   points at the value true, since that is the value of the known_entity
   claim.

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "known_entity"
     ]
   ]
   claim_pointer[0].unit_type = map_key; /* 0 */
   claim_pointer[0].opaque_key = "known_entity";


   /* This feels like nicer names to me */
   pointer_unit[0].unit_type = via_key;
   pointer_unit[0].key.type = string;
   pointer_unit[0].key.value = "known_entity";

5.2.  Matching Lists and Sequences by Absolute Position

   The value of an element in an absolute position in a list is accessed
   using the array_position pointer unit type.  The index value
   corresponds to the position counting from 0.

   The claim pointer below using the example JSON document above would
   point at the value true as well, the 3rd element of the service_flags
   array.

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "service_flags"
     ],  /* points to entire array */
     [
       token_type = array_position,
       index = 2
     ]
   ]

   /* claim_pointer[0] points to entire array */
   claim_pointer[0].unit_type = map_key; /* 0 */
   claim_pointer[0].opaque_key = "service_flags";

   /* claim_pointer[1] points to 3rd element (true) */
   claim_pointer[1].unit_type = array_position; /* 1 */
   claim_pointer[1].index = 2;

   If there is no array, or the array does not have an element at the
   requested position, the claim pointer does not point at anything.  If
   the index above was instead 7, or the value of service_flags was not
   an array, the claim pointer would not point at any value.

   As previously mentioned, the elements of an X.509 SEQUENCE with
   optional elements (such as tbsCertificate) are given a logical
   position from zero as if all possible optional elements are present.

5.3.  Matching an Element in a List by an Identifier in the List

   The array_search claim pointer unit type, can search an array of an
   ASN.1 SEQUNCE OF for the first entry which matched the nested claim
   pointer in nested_claim_pointer.

   The claim pointer below begins by pointing at the value of the entire
   nodes array.  Then, starting from the nodes array, its nested claim
   pointer points at the value of the processor object and compares it
   to the string value "DCBA-10177".  Finding a match, the top-level
   claim_pointer now points at the first element in the nodes array.
   Finally, the next claim pointer unit looks for a domain object in the
   first element of the nodes array.  The claim pointer now points at
   the value "smart.example".

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "nodes"
     ], /* points to entire array of nodes elements */
     [
       token_type = array_search,
       nested_claim_pointer = [{
         claim_pointer = [
           [
             token_type = map_key,
             opaque_key = "processor"
           ]    /* find an element with a `processor` object */
         ],
         value_semantics = string,  /* of type string         */
         match_on = utf8_ci,        /* UTF-8 case insensitive */
         test_value = "DCBA-10177"  /* matching this value    */
       }]
     ], /* pointer is at first element of the nodes array */
     [
       token_type = map_key,
       opaque_key = "domain"
     ]
   ]

   Instead imagine searching for the value of processor in the first
   element that matches the domain "smart.example".  We would use the
   following claim_pointer instead, which would point to the value
   "DCBA-10177" in the first element's processor object.

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "nodes"
     ], /* points to entire array of nodes elements */
     [
       token_type = array_search,
       nested_claim_pointers = [{
         claim_pointer = [
           [
             token_type = map_key,
             opaque_key = "domain"
           ]    /* find an element with a `domain` object */
         ],
         value_semantics = domain,    /* of type domain         */
         match_on = domain_name,      /* match a valid domain   */
         test_value = "smart.example" /* with this value        */
       }]
     ], /* pointer is at first element of the nodes array */
     [
       token_type = map_key,
       opaque_key = "processor"
     ]
   ]

   Finally, imagine that the value of the domain field was instead "xn--
   ingnieux-d1a.example", the match_on type was "punycode" and the
   test_value was "ingénieux.example".  This would also point to the
   same value ("DCBA-10177") since the punycode representation of the
   Internationalized Domain Name (IDN) or "punycode" representation of
   "ingénieux.example" is "xn--ingnieux-d1a.example".

5.4.  Matching multiple claim pointers

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "nodes"
     ], /* points to entire array of nodes elements */
     [
       token_type = array_search,
       nested_claim_pointers = [
         {
           claim_pointer = [
             [
               token_type = map_key,
               opaque_key = "domain"
             ]    /* find an element with a `domain` object */
           ],
           value_semantics = domain,    /* of type domain         */
           match_on = domain_name,      /* match a valid domain   */
           test_value = "smart.example" /* with this value        */
         },
         {
           claim_pointer = [
             [
               token_type = map_key,
               opaque_key = "origin"
             ],
             [
               token_type = map_key,
               opaque_key = "country"
             ]
           ],
           value_semantics = string,
           match_on = utf8ci,
           test_value = "us"
         }
       ] /* first element with both country = us           */
         /*                     AND domain = smart.example */
     ], /* pointer is at first element of the nodes array */
     [
       token_type = map_key,
       opaque_key = "processor"
     ]
   ]

5.5.  Matching with Numerical Predicates

     test_value = "eur_per_hour"

   value_semantics = number,
   match_on = number,
   operation = greater_or_equal,
   test_value = 200.0

5.6.  Matching Parts of URIs and email addresses

   value_semantics = uri,
   match_on = hostpart,
   test_value = "example.com"

5.7.  Matching Arbitrary Substrings

   mimi://example.com/u/46133c9e-df4c-4c88-91d2-00a527bdd0f7

   value_semantics = uri,
   match_on = uripath,
   operation = substring,
     start = 3,
     length = 36
   test_value = "46133c9e-df4c-4c88-91d2-00a527bdd0f7"

6.  some scraps here

   A ClaimPointerUnit can consist of a handful of types

   map_key

   array_index

   index matches the 0-indexed element of the array

   array_search

   matches the first element in the searched array which matches all of
   the nested_claim_pointers

   it returns the value of the found array element

   for example

   map_search

   is less commonly used, but needed when accessing a map key that
   itself has a nested structure

   {
     "abc": "foo"
     "def": [
        "carrot",
        "tomato",
        2.5,
        true
     ],
     "ghi": [
       [
       ],
       [
       ],
       {
         "roles": ["Employees", "Boston", "PR", "Manager"],
         "start_date": "01-Apr-2021"
       }
     ],
     "jkl": {
        "AAA": "all \"a\"'s",
        "BBB": "all b's"
     },
     "xyz": 1.0
   }

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "known_entity"
     ]
   ]
   match_on = bool,
   opaque_value = true
   MATCH

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "some_nonexistent_key"
     ]
   ]
   /* value is null */
   match_on = bool,
   opaque_value = true
   NO MATCH

   claim_pointer = [
     [
       token_type = array_position,
       index = 3
     ]
   ]
   /* value is null (there is no array or has fewer elements) */
   match_on = utf8_ci,
   opaque_value = "us"
   NO MATCH


   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "service_flags"
     ],  /* points to entire array */
     [
       token_type = array_position,
       index = 2
     ]
   ]
   /* value is [ true ] (value of 3rd element in array) */
   match_on = bool,
   opaque_value = true
   MATCH

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "nodes"
     ], /* points to entire array of nodes elements */
     [
       token_type = array_search,
       nested_claim_pointer = [
         [
           token_type = map_key,
           opaque_value = "processor"
         ]
       ],
       match_on = string,
       test_value = "DCBA-10177"
       MATCH
     ], /* pointer is at first element of the nodes array */
     [
       token_type = map_key,
       opaque_key = "domain"
     ]
   ]
   /* value is [ "smart.example" ] */
   match_on = domain
   opaque_value = "smart.example"
   MATCH

   Imagine the match is on an IDN domain and the value of the domain
   object was "xn--ingnieux-d1a.example".

   match_on = punycode test_value = "ingénieux.example"

   claim_pointer = [
     [
       token_type = map_key,
       opaque_key = "nodes"
     ], /* points to entire array of nodes elements */
     [
       token_type = array_search,
       nested_claim_pointer = [
         [
           token_type = map_key,
           opaque_value = "origin"
         ], /* value of first element is origin map */
         [
           token_type = map_key,
           test_value = "country"
         ] /* value of first element is "us" */
       ],
       match_on = string,
       test_value = "us"
       MATCH
     ], /* pointer is at first element of the nodes array */
     [
       token_type = map_key,
       opaque_key = "domain"
     ]
   ]
   /* value is [ "smart.example" ] */
   match_on = domain
   opaque_value = "smart.example"
   MATCH

   NEXT example match both processor and domain in array_search
   claim_pointer =

   NEXT example match predicate ≥ 200.00 eur per hour does this require
   ANDs to get ranges?

   NEXT example well-defined parts of URIs and email

   NEXT example substrings

7.  Match Syntax Definition

   enum {
       reserved (0),
       x509 (1),
       jwt (2),
       cwt(3),
       (255)
   } ClaimFamily;

   enum {
       number,
       int,
       float,
       bool,
       date,
       bytes (0),
       string (1),
       domain (2),
       uri (3),
       https_uri,
       mimi_uri,
       email (4),
       (255)
   } ClaimSemantics;

   enum {
       exists,
       number,
       int,
       uint,
       float,
       finite_float,
       bool,
       secs_since_epoch,
       iso8601,
       bytes (0),
       hex,
       base64,
       base64url,
       der,
       pem,
       ipv4,
       ipv6,
       deterministic_cbor,
       utf8 (1),
       utf8_ci ,
       nfc,
       nfd,
       canonical_json,
       domain (2),
       punycode,
       email_address,
       generic_uri,
       https_uri,
       userpart (6),
       hostpart (7),
       uri_path (8),
       mimi_uri,
       user_id (3),
       device_id (4),
       room_id (5),
       (255)
   } MatchOn;

   enum {
       member_name (0),
       array_position (1),
       array_search (2),
       tagged_value (3), /* CBOR only */
       bstr_encoded (4), /* CBOR only */
       (255)
   } ClaimUnitType;




   struct {
       JwtTokenType token_type;
       select (token_type) {
           case member_name:
               opaque name<V>;
           case array_index:
               uint index;
       }
   } JwtToken;

   struct {
       JwtToken claim_pointer<V>;
   } JwtClaimRoot;

   enum {
       map_key (0),
       array_index (1),
       tagged_value (2),
       bstr_encoded (3),
       (255)
   } TokenType;

   struct {
       TokenType token_type;
       select (token_type) {
           case map_key:
               opaque opaque_key<V>;
           case array_index:
               uint index;
           case array_search:
               ClaimMatch nested_matches<V>;
           case tagged_value:
               uint tag;
           case bstr_encoded:
               struct {};
       }
   } ClaimPointerUnit;

   enum {
       equal (0),
       less_than (1),
       less_than_or_equal (2),
       greater_than (3),
       greater_than_or_equal (4),
       len_bytes,
       len_chars,
       contains,
       starts_with,
       ends_with,
       substring,
       path_slice,
   } OperationType;

   struct {
     OperationType operation_type;
     select (operation_type) {
       case starts_with:
           optional<uint> length;
       case ends_width:
           optional<uint> length;
       case substring:
           uint start_position;
           uint length;
       case path_slice:
           uint path_index;
     };
   } Operation;

   struct {
       ClaimPointerUnit claim_pointer<V>;
       ClaimSemantics claim_semantics;
       MatchOn match_on;
       optional<Operation> operation;
       opaque matching_value<V>;
   } ClaimMatch

   struct {
       ClaimFamily claim_family;
       select (claim_family) {
           case json:
               JsonType json_type;
               select (json_type) {
                   case number:
                       Double value;
                   case string:
                   case object:
                   case array:
                       Bytes value;
                   case no_match:
                   case true:
                   case false:
                   case null:
                       struct {};
               }
           case cbor:
               Bytes cbor_encoding;
           case asn1:
       };
   } MapKey

   case no_match:
       struct {};
   case uint:
   case nint:
       uint64 value;
   case float
       Double value;
   case array:
   case map:
   case text_string:
   case byte_string:
       Bytes value;
   case tag:
       uint64 tag;
       Bytes value;
   case undefined:
       select {};
   case simple:
       uint8 value;


   enum JsonType {
       no_match (0),
       number (1),
       string (2),
       object (3),
       array (4),
       true (5),
       false (6),
       null (7)
       (255)
   }



   struct {
       CwtToken claim_pointer<V>;
   } CwtClaimRoot;

   struct {
       ClaimFamily claim_family;
       select (claim_family) {
           case x509:
               opaque oid<V>;
           case jwt:
               JwtClaimRoot claim_root;
           case cwt:
               CwtClaimRoot claim_root;
       }
       ClaimSemantics claim_semantics;
       MatchOn match_on;
       bool match_any_in_list;
       opaque target_value<V>;
   } Claim;

8.  More examples

8.1.  CBOR Examples

   {                                   # contents are level 1
     1: "https://issuer.example",
     ...
     502: 1(1549560720),               # tagged value is level 2
     504: [                            # contents are level 2
       {                               # contents are level 3
         ...
         501: "DCBA-101777",
         503: {                        # contents are level 4
           1: "us",
           ...
         },
         505: 4(                       # decimal fraction tag
           [                           #   273.15
             -2,
             27315                     # level 5
           ]
         )
       },
       ...
     ],
     509: [false, false, true, false]
   }

8.1.1.  CBOR example with tagged value access directly as opaque_value

8.1.2.  CBOR example parsing into tagged value

8.1.3.  CBOR example with custom simple values ?? - maybe not needed

8.2.  X.509 Examples

SEQUENCE (1 elem)
  SET (1 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.4.3 commonName (X.520 DN component)
      PrintableString github.com
...
    SEQUENCE (3 elem)
      OBJECT IDENTIFIER 2.5.29.15 keyUsage (X.509 extension)
      BOOLEAN true
      OCTET STRING (4 byte) 03020780
        BIT STRING (1 bit) 1
    SEQUENCE (3 elem)
      OBJECT IDENTIFIER 2.5.29.19 basicConstraints (X.509 extension)
      BOOLEAN true
      OCTET STRING (2 byte) 3000
        SEQUENCE (0 elem)
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.29.37 extKeyUsage (X.509 extension)
      OCTET STRING (22 byte) 301406082B0601050507030106082B06010505070302
        SEQUENCE (2 elem)
          OBJECT IDENTIFIER 1.3.6.1.5.5.7.3.1 serverAuth (PKIX key purpose)
          OBJECT IDENTIFIER 1.3.6.1.5.5.7.3.2 clientAuth (PKIX key purpose)
...
    SEQUENCE (2 elem)
      OBJECT IDENTIFIER 2.5.29.17 subjectAltName (X.509 extension)
      OCTET STRING (30 byte) 301C820A6769746875622E636F6D820E7777772E6769746875622E636F6D
        SEQUENCE (2 elem)
          [2] (10 byte) github.com
          [2] (14 byte) www.github.com

8.2.1.  Simple X.509 example (CN)

8.2.2.  X.509 Matching one DNS item in issuerAltName

8.2.3.  X.509 matching one URI part of subjectAltName

8.2.4.  X.509 matching one URI part of subjectAltName with a domain
        substring

claim_pointer = [
  [
    type = oid,
    value = 2.5.29.17 = 0x55 1d 11   # subjectAltName
  ],
  [
    type = array_serach,
    nested_claim_pointer = [
      [
      ]
    ],
    semantics = uri,
    match_on = domain / userpart / user_id
    test_value = "provider.example"
    MATCH
  ] /* value is [ ["URI", "https://provider.example/path"] ] */
],
semantics = uri,
match_on = exists,
test_value = true
MATCH

try email?  match domain in nester pointer, match on user in main match??

   RFC5820 matches only host part of URIs??

9.  Old text on Preauth

   Preauthorized users are MIMI users and external senders that have
   authorization to adopt a role in a room by virtue of certain
   credential claims or properties, as opposed to being individually
   enumerated in the participant list.  For example, a room for employee
   benefits might be available to join with the regular participant role
   to all full-time employees with a residence in a specific country;
   while anyone working in the human resources department might be able
   to join the same room as a moderator.  This data structure is
   consulted in two situations: for external joins (external commits)
   and external proposals when the requester does not already appear in
   the participant list; and separately when an existing participant
   explicitly tries to change its _own_ role.

      Only consulting Preauthorized users in these cases prevents
      several attacks.  For example, it prevents an explicitly banned
      user from rejoining a group based on a preauthorization.

   PreAuthData is the format of the data field inside the ComponentData
   struct for the Preauthorized Participants component in the
   application_data GroupContext extension.

   The individual PreAuthRoleEntry rules in PreAuthData are consulted
   one at a time.  A PreAuthRoleEntry matches for a requester when every
   Claim.claim_id has a corresponding claim in the requester's MLS
   Credential which exactly matches the corresponding claim_value.  When
   the rules in a Preauthorized users struct match multiple roles, the
   requesting client receives the first role which matches its claims.

      *TODO*: refactor Claims

   struct {
     /* MLS Credential Type of the "claim"  */
     CredentialType credential_type;
     /* the binary representation of an X.509 OID, a JWT claim name  */
     /* string, or the CBOR map claim key in a CWT (an int or tstr)  */
     opaque id<V>;
   } ClaimId;

   struct {
     ClaimId claim_id;
     opaque claim_value<V>;
   } Claim;

   struct {
     /* when all claims in the claimset are satisfied, the claimset */
     */ is satisfied */
     Claim claimset<V>;
     Role target_role;
   } PreAuthRoleEntry;

   struct {
     PreAuthRoleEntry preauthorized_entries<V>;
   } PreAuthData;

   PreAuthData preauth_list;
   PreAuthData PreAuthUpdate;

   PreAuthUpdate (which has the same format as PreAuthData) is the
   format of the update field inside the AppDataUpdate struct in an
   AppDataUpdate Proposal for the Preauthorized Participants component.
   If the contents of the update field are valid and if the proposer is
   authorized to generate such an update, the value of the update field
   completely replaces the value of the data field.

      As with the definition of roles, in MIMI it is not expected that
      the definition of Preauthorized users would change frequently.
      Instead the claims in the underlying credentials would be modified
      without modifying the preauthorization policy.

   Changing Preauthorized user definitions is sufficiently disruptive,
   that an update to this component is not valid if it appears in the
   same commit as any Participant List change, except for user removals.

   Because the Preauthorized users component usually authorizes non-
   members, it is also a natural choice for providing concrete
   authorization for policy enforcing systems incorporated into or which
   run in coordination with the MIMI Hub provider or specific MLS
   Distribution Services.  For example, a preauthorized role could allow
   the Hub to remove participants and to ban them, but not to add any
   users or devices.  This unifies the authorization model for members
   and non-members.

10.  Security Considerations

   TODO Security

11.  IANA Considerations

   This document has no IANA actions.

12.  Normative References

   [I-D.ietf-cbor-serialization]
              Lundblade, L., "CBOR Serialization and Determinism", Work
              in Progress, Internet-Draft, draft-ietf-cbor-
              serialization-01, 5 December 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-cbor-
              serialization-01>.

   [I-D.ietf-mimi-room-policy]
              Mahy, R., "Room Policy for the More Instant Messaging
              Interoperability (MIMI) Protocol", Work in Progress,
              Internet-Draft, draft-ietf-mimi-room-policy-03, 18
              December 2025, <https://datatracker.ietf.org/doc/html/
              draft-ietf-mimi-room-policy-03>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/rfc/rfc5280>.

   [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
              <https://www.rfc-editor.org/rfc/rfc7519>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8392]  Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig,
              "CBOR Web Token (CWT)", RFC 8392, DOI 10.17487/RFC8392,
              May 2018, <https://www.rfc-editor.org/rfc/rfc8392>.

   [RFC9420]  Barnes, R., Beurdouche, B., Robert, R., Millican, J.,
              Omara, E., and K. Cohn-Gordon, "The Messaging Layer
              Security (MLS) Protocol", RFC 9420, DOI 10.17487/RFC9420,
              July 2023, <https://www.rfc-editor.org/rfc/rfc9420>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Rohan Mahy
   Email: rohan.ietf@gmail.com
